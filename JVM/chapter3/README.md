# 垃圾收集器与内存分配策略

垃圾收集（GC）需要完成的三件事情：
- 哪些内存需要回收
- 什么时候回收
- 如何回收

程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭。栈帧随方法进入和退出而入栈和出栈，栈帧分配多少内存在编译期基本就是已知的。所以这几个区域的内存分配和回收都具备确定性。

Java堆和方法区不一样，这部分区域的内存分配和回收都是动态的，垃圾收集器所关注的都是这部分内存。

## 如何确定对象已死呢

### 引用计数算法
给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻，计数器都为0的对象就是不可能再被使用的。

**缺点：**  
无法解决对象之间的相互引用问题

### 根搜索算法
通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连时，则证明此对象是不可用的。Java语言使用的就是根搜索算法

可以作为`GC Roots`的对象包括以下几种：
- 虚拟机栈（栈帧中的本地变量表）中的引用对象
- 方法区中的类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（即一般所说的Native方法）的引用的对象

### Java中的引用
Java中的引用分为四种：
- 强引用——代码中普遍存在，类似`Object obj = new Object()`，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象
- 软引用——用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中并进行第二次回收，如果这次回收还是没有足够的内存，才会抛出内存溢出异常。`SoftReference`类来实现软引用
- 弱引用——描述非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。`WeakReference`类来实现弱引用
- 虚引用——最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个实例对象。当一个对象设置虚引用关联的位移目的就是希望能在这个对象被收集器回收时收到一个系统通知。`PhantomReference`类来实现虚引用

