# 虚拟机类加载机制

- 虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型
- 在Java语言里面，类型的加载和连接过程都是在程序运行期间完成的，这样会在类加载时稍微增加一些性能开销，但是却能为Java应用程序提供高度的灵活性，Java中天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的

## 类加载的时机

- 类的生命周期：加载、验证、准备、解析、初始化、使用、卸载。验证、准备和解析统称为连接

类的声明周期示意图如下：  
![类的生命周期](./7-1.png)

- 加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定和晚期绑定）
- 加载、验证、准备、初始化、卸载这些阶段通常都是互相交叉地混合式进行，通常会在一个阶段执行的过程中调用或激活另外一个阶段
- 对于初始化阶段，虚拟机规范严格规定了有且只有四种情况必须立即对类进行“初始化”：
    - 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见Java代码场景是：使用`new`关键字实例化对象的时候、读取或设置一个类的静态字段（被`final`修饰）、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候
    - 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化
    - 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
    - 当虚拟机启动时，用户需要指定一个要执行的主类（包含`main()`方法的那个类），虚拟机会先初始化这个主类
- 以上四种场景中的行为称为对一个类进行主动引用。除此之外所有引用类的方式，都不会触发其初始化，称为被动引用
- 被动引用部分场景如下：
    - 通过子类引用父类的静态字段，不会导致子类初始化。可通过`-XX:+TraceClassLoading`参数导致子类的加载
    - 通过数组定义来引用类，不会触发此类的初始化
    - 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化
- 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化

## 类加载过程



